# 객체\(Object\)

## 객체 지향 언어

현실세계는 사물이나 개념처럼 독립되고 구분되는 **각각의 객체로 이루어져** 있으며, 발생하는 **모든 사건들은 객체간의 상호작용**입니다.

이 개념을 컴퓨터로 옮겨 만들어낸 것이 바로 _**객체지향 언어**_입니다.

### 현실세계에서 객체란?

현실세계에서 독립적으로 존재하는것들 \(유형, 무형, 개념등등..\)

즉, 자신의 속성\(값, data\)과 기능\(동작,행동\)을 다른것들과 구분되어 식별 가능한것을 포함합니다.

### 자바에서 객체\(Object\)란?

클래스에 정의된 내용대로 new 연산자를 통해 메모리영역에 생성된것

![&#xBC30;&#xC5F4;&#xACFC; &#xAC19;&#xC740; &#xAC83;&#xB3C4; &#xAC1D;&#xCCB4;&#xC785;&#xB2C8;&#xB2E4;.](../../.gitbook/assets/image%20%2852%29.png)

### 클래스

객체를 생성하기 위해 필요하며, 객체의 특성에 대한 정의를 한것으로 캡슐화를 통해 기능을 포함한 개념 사물이나 개념의 공통요소를 추상화 \(abstraction\)하여 정의하는 것을 클래스라 합니다. 

예를들면 제품의 설계도나 빵틀이 있겠죠?

## 

## 추상화\(abstract\)

### 추상화과정

1. 내가 구현하고자 하는 프로그램에서 필요한 객체들을 생각해보기
2. 그 객체들이 가지고 있는 공통적인 속성, 기능들을 모두 추출\(몇개가 있든\)
3. 추출된것들을 가지고 내가 구현하고자 하는 프로그램의 '실질적 목적'에 맞춰 불필요한것들 제거\(간소화\)
4. 그렇게 최종적으로 선정된 속성들을 가지고 어떤 자료형, 어떤 변수명으로 사용할건지 생각.

그렇다면 학생관련 프로그램으로 예를들어 볼까요?

1단계

* 학생관련객체 - 홍길동학생, 김영희학생,홍길녀, ....

2단계

* 공통적인 속성 및 기능 - 이름, 나이, 머리색, 국어점수, 키, 학년, 반, 점수, ....

3단계

* 학생 "인적사항" 관리 Prog  - 이름, 나이, 주소, 전화번호, 학년, 반 
* 학생 "건강" 관리 Prog - 이름, 키, 달리기속도, 몸무게, 먹는것, ..
* _최종적으로 '이름', '나이', '키' 로 추려졌다고 가정하겠습니다._

4단계

* 이름 --&gt; String name;
* 나이 --&gt; int age;
* 키     --&gt; double height;

그렇다면 선정된 것들을 가지고 프로그래밍을 진행해 볼까요?

#### 먼저 '변수'만을 가지고 구현한다면 어떻게 될까요?

{% hint style="info" %}
\*변수\* 

홍길동객체 -&gt; String name1 ="홍길동"

                           int age1 = 20;

                            double height1 = 162.3

김영희객체 -&gt;   .....
{% endhint %}

변수는 값을 하나씩만 보관할수 있기때문에 매우 번거롭습니다..

#### 그렇다면 배열로 프로그램을 구현해볼까요?

{% hint style="info" %}
\*배열\*

학생이름 -&gt; String name ={"홍길동","김영희","홍길녀",...};

학생나이 -&gt;       int  age    ={20, 21, 22, ....};

학생 키     -&gt;    ...
{% endhint %}

물론 배열보다는 비교적 쉽게 만들수 있겠지만 여전히 불편합니다. 

특히 배열은 선언할 때 크기를 선언해주기 때문에 추가나 지워주는 과정에서 데이터의 불변성을 잃기가 쉽다는 단점이 있습니다.

자 그럼 다음에는 구조체에 대하여 알아보겠습니다.

## 간단한 객체 맛보기

### 구조체

String값도 보관하고, int값도, double값도 함께 보관할수 있는 배열같은 자료형  

즉, **클래스**입니다.

그렇다면 **Student클래스**를 만들어 안에 **필드**라는 것을 통해 name, age, height를 넣어볼까요?

사실 클래스는 필드부, 생성자부, 메소드부가 있습니다. 

한번 다양한 자료형을 담을 수 있는 필드부를 작성해볼까요?

```java
public class Student {

	//필드부
	String name;
	int age;
	double height;
	
}
//자료형 변수명;
```

지금은 

```java
자료형 변수명;
```

이런식으로 선언을 해줬지만 사실 아래와 같은 형식으로 작성해야 합니다.

```java
접근제한자 [예약어] 자료형 변수명;
```

* 접근 제한자 :여기에 접근할 수 있는 범위를 제한할 수 있습니다.
*  ex\)  public &gt; protected &gt; default &gt; private

```java
public String name;
public int age;
public double height;
```

이렇게 말이죠!

이걸 어떻게 활용해야 할까요? 아래 코드를 봐주세요.

```java
public static void main(String[] args) {

		int[]arr = new int[5];
		
		Student hong = new Student();
	}
```

객체를 만들어봅시다!

```java
public static void main(String[] args) {
		
		//홍길동이라는 객체를 만들기 위해서
		//new 라는 연산자를 통해 Heap저장소에 공간을 할당받아야 한다.
		Student hong = new Student();
		
		hong.name = "홍길동";
		hong.age = 20;
		hong.height = 162.3;
		//직접적으로 접근하여 값을 초기화해준 것이다.
		
		Student kim = new Student();
		
		kim.name = "홍길동";
		kim.age = 20;
		kim.height = 162.3;
	}
```

그렇다면 다른학생들도 값을 할당해줄 수 있겠죠?

참고로,  hong이나 kim과 같은 공간의 크기는 필드에 있는 갯수만큼 할당된답니다.

하지만 이렇게 직접접근을 하게 된다면 외부에서 값을 마음대로 변경해버릴 수 있습니다.

그래서 우리는 정보은닉 기술인 캡슐화를 진행해 볼 것입니다.

### 캡슐화

필드부 

필드 == 멤버변수 ==인스턴스변수

표현법

```java
접근제한자 [예약어] 자료형 변수명;
```

{% hint style="warning" %}
필드부에서 접근제한자는 private로 해서 직접적으로 접근이 불가능하게 해야 한답니다.
{% endhint %}

Private로 접근제한자를 설정해볼까요?

```java
private String name;
private int age;
private double height;
```

자 그럼 아까와 같은 방식으로 직접접근을 해볼까요?

```java
Student hong = new Student();
		
		hong.name = "홍길동";
		hong.age = 20;
		hong.height = 162.3;
```

오류가 발생합니다.. 어떻게 해야할까요?

바로 메소드를 통해 간접적으로 접근하면 됩니다.

우리가 실행클래스에서 호출하던 그 메소드처럼 말이죠.

그럼 이제 우리가 사용하던 메소드부에 대하여 알아볼까요?

메소드부

표현법은 다음과 같습니다.

```java
접근제한자 반환형 메소드명([메게변수]){
    ///기능구현////
}

public void method1(){ 기능구현 }
```

참고로 매게변수에는 만약 파라미터를 문자열로 전송하고 싶다면 

String 변수명  정수형이라면 int 변수명   이런식으로 작성하셔야만 합니다.

자 그럼 간접호출을 위한 메소드를 만들어보겠습니다.

### 

### setter 메소드

담고자 하는 데이터를 전달받아서 해당 필드에 초기화 시켜주는 기능의 메소드 == setter 메소드라고 하는데,

주로 setter메소드명을 지어줄때는 setXXX라고 지어준답니다.

```java
//String newName = "홍길동"
Public void setName(String newName){
   //받은 문자열newName을 name으로 지정
   name = newName; 
}
```

이제 나머지 필드들도 메소드를 만들어줄까요?

{% hint style="info" %}
또한 파라미터명 또한 필드명과 일치시켜주는 것이 관례입니다.
{% endhint %}

자 그러하면 아래의 코드와 같이 필드의 name을 파라미터name으로 지정하면 어떻게 될까요?

```java
Public void setName(String name){
   name = name; //오류
}
```

이렇게 된다면 파라미터의 name에 파라미터 name을 대입시키기때문에 아무 효과가 없습니다.

필드위에 있는 변수를 가리킬 때에는 변수명 앞에 `this.`을 붙여주세요

```java
Public void setName(String name){
   this.name = name; 
}
```

그렇다면 메인메소드 클래스로 돌아가서 값을 지정해 볼까요?

```java
public static void main(String[] args) {
		Student hong = new Student();
		
		hong.setName("홍길동");
		hong.setAge(20);
	}
```

이해하기 조금 어려울 수 있습니다.

다시 설명하면 아래와 같습니다.

1. 실행클래스 메인메소드에서 `setName()`메소드에 "홍길동" 파라메터 전송
2. "홍길동"파라미터를 전달받은 다른 클래스에서 선언되있는 `setName()`메소드의 내부에서 필드의 private변수에 전달받은 "홍길동" 대입.
3. private 변수의 값이 바뀜

{% hint style="info" %}
직접적으로 다른 클래스의 필드에 선언된 private변수에는 접근이 불가능하기 때문에,

같은 클래스 안에 메소드부에서 public접근권한의 메소드를 만든뒤 메소드에 들어온 파라메터를 필드의 private변수에 대입시켜 주는 것입니다.
{% endhint %}

하지만 `hong.name`을 출력해본다면 출력이 잘 되지 않을것입니다..

이제 각 필드에 담긴 값을 반환해주는 기능을 하는 메소드 즉,

### 

### getter 메소드

에 대하여 알아보겠습니다.

getter메소드도 setter과 마찬가지로 `getXXX()` 로 이름을 지어줍니다.

getter메소드는 필드에 담긴 값을 반환만 시켜주기 때문에 별도로 전달되는 파라미터가 없어도 됩니다.

필드에 있는 name값을 반환해볼까요?

```java
public void getName(){
    return name;  //name값을 호출한곳으로 반환해주겠다.
}
```

하지만 이렇게 코드를 작성해도 오류가 나타납니다. 

그 이유는 `void` 때문입니다. `void`가 위치한 자리는 반환할 값의 자료형을 정의해주는 위치입니다. 

`void`는 반환값이 없다는 의미이죠

한번 고쳐볼까요?

```java
public String getName(){
    return name;  
}
```

이렇게 해주면 private한 변수를 다른곳에서 사용할 수 있겠죠??

여기까지가 기본적인 class의 형태입니다.

또한 데이터의 불변성도 중요한 개념이니 한번 공부해보시는 것을 추천드립니다.

각 필드에 직접적으로 접근이 불가능 하게끔 처리하는 정보은닉\(private\), 

정보은닉으로 인해 직접접근이 불가능해진 데이터를 초기화 하거나 조회할 수 있는 `setter/getter`메소드

꼭 숙지해주세요

